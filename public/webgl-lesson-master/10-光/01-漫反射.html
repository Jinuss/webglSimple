<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Êº´ÂèçÂ∞Ñ</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <script id="vs" type="x-shader/x-vertex">
      attribute vec4 a_Position;
      attribute vec3 a_Normal;
      uniform mat4 u_PvMatrix;
      uniform mat4 u_ModelMatrix;
      varying vec3 v_Normal;
      void main(){
        gl_Position = u_PvMatrix*u_ModelMatrix*a_Position;
        v_Normal=a_Normal;
      }
    </script>
    <script id="fs" type="x-shader/x-fragment">
      precision mediump float;
      uniform vec3 u_Kd;
      uniform vec3 u_LightDir;
      varying vec3 v_Normal;
      void main(){
        vec3 diffuse=u_Kd*max(0.0,dot(v_Normal,u_LightDir));
        gl_FragColor=vec4(diffuse,1.0);
      }
    </script>
    <script type="module">
      import { createProgram, imgPromise } from "../jsm/Utils.js";
      import {
        Matrix4,
        PerspectiveCamera,
        Vector3,
        SphereGeometry,
      } from "../jsm/three.module.js";
      import { fetchFile, loadShaderFiles } from "../jsm/loadShaderFiles.js";
      import OrbitControls from "./lv/OrbitControls.js";
      import Mat from "./lv/Mat.js";
      import Geo from "./lv/Geo.js";
      import Obj3D from "./lv/Obj3D.js";
      import Scene from "./lv/Scene.js";

      loadShaderFiles("./lv/vs.vert", "./lv/fs.frag").then((resp) => {
        console.log("üöÄ ~ resp:", resp);
      });

      const canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      let gl = canvas.getContext("webgl");
      gl.clearColor(0, 0, 0, 1);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.DEPTH_TEST);

      // ÁõÆÊ†áÁÇπ
      const target = new Vector3();
      //ËßÜÁÇπ
      const eye = new Vector3(0, 0, 3);
      const [fov, aspect, near, far] = [
        45,
        canvas.width / canvas.height,
        1,
        20,
      ];
      // ÈÄèËßÜÁõ∏Êú∫
      const camera = new PerspectiveCamera(fov, aspect, near, far);
      camera.position.copy(eye);
      // ËΩ®ÈÅìÊéßÂà∂Âô®
      const orbit = new OrbitControls({ camera, target, dom: canvas });

      // Èò≥ÂÖâÂÖâÁ∫øÊñπÂêë
      const lightDir = new Vector3(0.5, 1, 1).normalize();
      // Êº´ÂèçÂ∞ÑÁ≥ªÊï∞- È¢úËâ≤
      const u_Kd = [0.7, 0.7, 0.7];
      // ÁêÉ‰Ωì
      const sphere = new SphereGeometry(0.5, 12, 12);
      // È°∂ÁÇπÈõÜÂêà
      const { array: vertices } = sphere.getAttribute("position");
      // Ê≥ïÁ∫øÈõÜÂêà
      const { array: normals } = sphere.getAttribute("normal");
      // È°∂ÁÇπÁ¥¢ÂºïÈõÜÂêà
      const { array: indexes } = sphere.index;

      // Âú∫ÊôØ
      const scene = new Scene({ gl });
      //Ê≥®ÂÜåÁ®ãÂ∫èÂØπË±°
      scene.registerProgram("Blinn-Phong", {
        program: createProgram(
          gl,
          document.getElementById("vs").innerText,
          document.getElementById("fs").innerText
        ),
        attributeNames: ["a_Position", "a_Normal"],
        uniformNames: ["u_PvMatrix", "u_ModelMatrix", "u_Kd", "u_LightDir"],
      });

      const mat = new Mat({
        program: "Blinn-Phong",
        data: {
          u_PvMatrix: {
            value: orbit.getPvMatrix().elements,
            type: "uniformMatrix4fv",
          },
          u_ModelMatrix: {
            value: new Matrix4().elements,
            type: "uniformMatrix4fv",
          },
          u_Kd: {
            value: u_Kd,
            type: "uniform3fv",
          },
          u_LightDir: {
            value: [...lightDir],
            type: "uniform3fv",
          },
        },
      });
      const geo = new Geo({
        data: {
          a_Position: {
            array: vertices,
            size: 3,
          },
          a_Normal: {
            array: normals,
            size: 3,
          },
        },
        index: {
          array: indexes,
        },
      });
      const obj = new Obj3D({ geo, mat });
      scene.add(obj);
      scene.draw();

      !(function ani() {
        orbit.getPvMatrix();
        scene.draw();
        requestAnimationFrame(ani);
      })();

      /* ÂèñÊ∂àÂè≥ÂáªËèúÂçïÁöÑÊòæÁ§∫ */
      canvas.addEventListener("contextmenu", (event) => {
        event.preventDefault();
      });
      /* ÊåáÈíàÊåâ‰∏ãÊó∂ÔºåËÆæÁΩÆÊãñÊãΩËµ∑Âßã‰ΩçÔºåËé∑ÂèñËΩ®ÈÅìÊéßÂà∂Âô®Áä∂ÊÄÅ„ÄÇ */
      canvas.addEventListener("pointerdown", (event) => {
        orbit.pointerdown(event);
      });
      /* ÊåáÈíàÁßªÂä®Êó∂ÔºåËã•ÊéßÂà∂Âô®Â§Ñ‰∫éÂπ≥ÁßªÁä∂ÊÄÅÔºåÂπ≥ÁßªÁõ∏Êú∫ÔºõËã•ÊéßÂà∂Âô®Â§Ñ‰∫éÊóãËΩ¨Áä∂ÊÄÅÔºåÊóãËΩ¨Áõ∏Êú∫„ÄÇ */
      canvas.addEventListener("pointermove", (event) => {
        orbit.pointermove(event);
      });
      /* ÊåáÈíàÊä¨Ëµ∑ */
      canvas.addEventListener("pointerup", (event) => {
        orbit.pointerup(event);
      });
      /* ÊªöËΩÆ‰∫ã‰ª∂ */
      canvas.addEventListener("wheel", (event) => {
        orbit.wheel(event);
      });
    </script>
  </body>
</html>
